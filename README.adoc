= CN1RPC
A library to facilitate RPC between Codename One clients and Java servers

== Synopsis

This library provides a minimal set of annotations to generate RPC client and server code for Codename One applications.  The library itself meant to be used in Java server projects, but it includes a mechanism to seamlessly keep client projects in sync.

== Tutorials

* **link:wiki/SimpleAdder-Tutorial[SimpleAdder Tutorial]** - An introductory tutorial for beginners on how to set up a very basic client-server application with CN1RPC
* **link:wiki/Movie-Database-Tutorial[Movie Database Tutorial]** - Level 2 tutorial, showing a more complex application that involves passing POJOs as parameters and return types.

== Installation

**Maven Projects**:

First clone this repo and install with Maven
----
$ git clone https://github.com/shannah/CN1RPC.git
$ cd CN1RPC/CodenameOneServerAnnotationsMaven
$ mvn install
----

Next add dependencies to your Java server project.

Add the following to your pom.xml:

----
<dependency>
    <groupId>com.codename1</groupId>
    <artifactId>cn1rpc</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
----

**Non-Maven Projects**

* Download https://github.com/shannah/CN1RPC/raw/master/TestWebApp/lib/cn1rpc-0.1.0-SNAPSHOT.jar[CN1RPC]
* Download https://github.com/shannah/CN1RPC/raw/master/TestWebApp/lib/javapoet-1.2.0-SNAPSHOT.jar[JavaPoet] (Required by CN1RPC)

Add them to your project's compile classpath.


== Usage

To create a web service that uses Codename One RPC, simply add the `@WebService` annotation to any class in your project.  Then all `public` `static` methods in that class will be accessible to your Codename One client using RPC (remote procedure calls).

=== A simple example:

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static int add(int a, int b) {
        return a+b;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            int result = proxy.add(1,2);  // should be 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

This is *ALL* the code you need to write.  Boiler-plate code is generated by Javac in the server project whenever it is compiled, and it is kept in sync so you don't have to worry about manually changing it later.

=== Example with Externalizable Classes

RPC methods can accept primitive types, strings, boxed types, arrays of primitive types, and arrays of strings.  In addition it can accept objects custom classes that are marked with the `@Externalizable` annotation.   All such classes are automatically shared by both the client and server projects.  This allows you to pass arbitrarily complex objects back and forth between the client and server using RPC.

E.g.

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.Externalizable;

@Externalizable
class CustomResponse {
    int responseCode;
    String message;
    int additionResult;
    
    //  some accessors and getters here ...
}
----

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static CustomResponse add(int a, int b) {
        int out = a+b;
        
        // Use the ExternalizableFactory class (which is generated inside
        // any package that includes @Externalizable classes to create
        // instances of @Externalizable classes).
        ExternalizableFactory f = new ExternalizableFactory();
        
        CustomResponse response = f.create(CustomResponse.class);
        response.setCode(200);
        response.setMessage("Successfully added two numbers");
        response.setAdditionResult(out);
        return response;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            CustomResponse response = proxy.add(1,2);
            response.getCode(); // 200
            response.getMessage(); 
            response.getAdditionResult(); // 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

=== Synchronizing Server and Client Project Classes

The annotation processor handles the generation of all boiler-plate code for both the server and client.  Generated client code is saved to a directory named `cn1-client-generated-sources` inside the server project's `build` directory (as a sibling directory of `generated-sources`).  

You can automatically export the generated client source files to your client project using the `exports` attribute of the `@WebService` annotation.  E.g.

[source,java]
----

@WebService(exports={"/path/to/ClientProject"})
public class TestWebServer {
   ...
}
----

You can also use a relative path (from the "source" directory of the server project).

[source,java]
----

@WebService(exports={"../../../ClientProject"})
public class TestWebServer {
   ...
}
----

== Troubleshooting & Known Issues

=== 404 Error Trying to Access Servlet 

When you try to run your Java Web Project in Netbeans by clicking the "Run" button, you are unable to access the servlet for your `@WebService` class, even though you are entering the correct URL.  However if you perform a clean build then deploy the .war file to your servlet container, it works fine.

The reason is that there is a bug in Netbeans that causes code generation to break when "Compile on Save" is enabled.

==== Solution

Disable http://wiki.netbeans.org/FaqCompileOnSave[Compile on Save] and "Deploy on Save" in your project.


