= CN1RPC
A library to facilitate RPC between Codename One clients and Java servers

== Synopsis

This library provides a minimal set of annotations to generate RPC client and server code for Codename One applications.  The library itself meant to be used in Java server projects, but it includes a mechanism to seamlessly keep client projects in sync.

== Usage

To create a web service that uses Codename One RPC, simply add the `@WebService` annotation to any class in your project.  Then all `public` `static` methods in that class will be accessible to your Codename One client using RPC (remote procedure calls).

=== A simple example:

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static int add(int a, int b) {
        return a+b;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            int result = proxy.add(1,2);  // should be 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

This is *ALL* the code you need to write.  Boiler-plate code is generated by Javac in the server project whenever it is compiled, and it is kept in sync so you don't have to worry about manually changing it later.

=== Example with Externalizable Classes

RPC methods can accept primitive types, strings, boxed types, arrays of primitive types, and arrays of strings.  In addition it can accept objects custom classes that are marked with the `@Externalizable` annotation.   All such classes are automatically shared by both the client and server projects.  This allows you to pass arbitrarily complex objects back and forth between the client and server using RPC.

E.g.

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.Externalizable;

@Externalizable
class CustomResponse {
    int responseCode;
    String message;
    int additionResult;
    
    //  some accessors and getters here ...
}
----

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static CustomResponse add(int a, int b) {
        int out = a+b;
        CustomResponse response = ExternalizableFactory.create(CustomResponse.class);
        response.setCode(200);
        response.setMessage("Successfully added two numbers");
        response.setAdditionResult(out);
        return response;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            CustomResponse response = proxy.add(1,2);
            response.getCode(); // 200
            response.getMessage(); 
            response.getAdditionResult(); // 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

=== Synchronizing Server and Client Project Classes

The annotation processor handles the generation of all boiler-plate code for both the server and client.  Generated client code is saved to a directory named `cn1-client-generated-sources` inside the server project's `build` directory (as a sibling directory of `generated-sources`).  There are three strategies that you can use for copying these files into your Codename One client project:

1. Manually copy them whenever you make changes the would cause the client files to be updated.
2. Set up an ANT script to run every time you build the server project to copy the source files into the client.
3. Use the `@CodenameOne` annotation on any class in your server project and provide the path to your Codename One client project.  E.g.

[source,java]
----
@CodenameOne(projectPath="/path/to/ClientProject")
class SomeClass{}
----

You can also use a relative path (from the "source" directory of the server project).

[source,java]
----
@CodenameOne(projectPath="../../../ClientProject")
class SomeClass{}
----



