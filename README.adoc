= CN1RPC
A library to facilitate RPC between Codename One clients and Java servers

== Synopsis

This library provides a minimal set of annotations to generate RPC client and server code for Codename One applications.  The library itself meant to be used in Java server projects, but it includes a mechanism to seamlessly keep client projects in sync.

== Installation

First clone this repo and install with Maven
----
$ git clone https://github.com/shannah/CN1RPC.git
$ cd CN1RPC/CodenameOneServerAnnotationsMaven
$ mvn clean install
----

Next add dependencies to your Java server project.

**Maven Projects**:

Add the following to your pom.xml:

----
<dependency>
    <groupId>com.codename1</groupId>
    <artifactId>cn1rpc</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
----

**Non-Maven Projects**

Add the following to your server project's classpath:

1. `CodenameOneServerAnnotationsMaven/target/cn1rpc-0.1.0.jar`
2. `TestWebApp/lib/javapoet-1.2.0-SNAPSHOT.jar`


== Usage

To create a web service that uses Codename One RPC, simply add the `@WebService` annotation to any class in your project.  Then all `public` `static` methods in that class will be accessible to your Codename One client using RPC (remote procedure calls).

=== A simple example:

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static int add(int a, int b) {
        return a+b;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            int result = proxy.add(1,2);  // should be 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

This is *ALL* the code you need to write.  Boiler-plate code is generated by Javac in the server project whenever it is compiled, and it is kept in sync so you don't have to worry about manually changing it later.

=== Example with Externalizable Classes

RPC methods can accept primitive types, strings, boxed types, arrays of primitive types, and arrays of strings.  In addition it can accept objects custom classes that are marked with the `@Externalizable` annotation.   All such classes are automatically shared by both the client and server projects.  This allows you to pass arbitrarily complex objects back and forth between the client and server using RPC.

E.g.

**Server-side Code**:

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.Externalizable;

@Externalizable
class CustomResponse {
    int responseCode;
    String message;
    int additionResult;
    
    //  some accessors and getters here ...
}
----

[source,java]
----
package com.example.myadder;

import com.codename1.ws.annotations.WebService;

@WebService
public class TestWebServer {
    public static CustomResponse add(int a, int b) {
        int out = a+b;
        
        // Use the ExternalizableFactory class (which is generated inside
        // any package that includes @Externalizable classes to create
        // instances of @Externalizable classes).
        ExternalizableFactory f = new ExternalizableFactory();
        
        CustomResponse response = f.create(CustomResponse.class);
        response.setCode(200);
        response.setMessage("Successfully added two numbers");
        response.setAdditionResult(out);
        return response;
    }
}
----

**Client-side Code**:

[source,java]
----
package com.example.myapp;

import com.example.myadder.TestWebServerProxy;

public class MyApp {
    public void start() {
        TestWebServerProxy proxy = new TestWebServerProxy("http://localhost:8080/myapp");
        try {
            CustomResponse response = proxy.add(1,2);
            response.getCode(); // 200
            response.getMessage(); 
            response.getAdditionResult(); // 3
        } catch (IOException ex) {
            //  deal with io error.
        }
    }
}
----

=== Synchronizing Server and Client Project Classes

The annotation processor handles the generation of all boiler-plate code for both the server and client.  Generated client code is saved to a directory named `cn1-client-generated-sources` inside the server project's `build` directory (as a sibling directory of `generated-sources`).  

You can automatically export the generated client source files to your client project using the `exports` attribute of the `@WebService` annotation.  E.g.

[source,java]
----

@WebService(exports={"/path/to/ClientProject"})
public class TestWebServer {
   ...
}
----

You can also use a relative path (from the "source" directory of the server project).

[source,java]
----

@WebService(exports={"../../../ClientProject"})
public class TestWebServer {
   ...
}
----



